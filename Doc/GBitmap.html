<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  GBitmap</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  <A HREF="#DOC.DOCU">GBitmap</A></H2></H2><BLOCKQUOTE>Bilevel and gray-level images.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CGPEnabled,MGPEnabled.html,CGBitmap,MGBitmap.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.1">Construction. </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.2">Initialization. </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.3">Accessing the pixels. </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.4">Managing gray levels. </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.5">Optimizing the memory usage.  </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.6">Additive Blit.  </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.7">Saving images.  </A></B>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.13.1.8">Stealing or borrowing the memory buffer (advanced). </A></B>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GPEnabled.html">GPEnabled</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPEnabled.html">GPEnabled</A>&amp; <B>operator=</B>(const <!1><A HREF="GPEnabled.html">GPEnabled</A> &amp; obj)
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>volatile   int <B>count</B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>virtual   void <B>destroy</B>()
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Bilevel and gray-level images.  Instances of class <TT>GBitmap</TT> represent
bilevel or gray-level images.  Images are usually represented using one
byte per pixel.  Value zero represents a white pixel.  A value equal to
the number of gray levels minus one represents a black pixel.  The number
of gray levels is returned by the function <!1><A HREF="GBitmap.html#DOC.1.4.13.1.4.1">get_grays</A> and can be
manipulated by the functions <!1><A HREF="GBitmap.html#DOC.1.4.13.1.4.2">set_grays</A> and <!1><A HREF="GBitmap.html#DOC.1.4.13.1.4.3">change_grays</A>.

<P>The bracket operator returns a pointer to the bytes composing one line of
the image.  This pointer can be used to read or write the image pixels.
Line zero represents the bottom line of the image.

<P>The memory organization is setup in such a way that you can safely read a
few pixels located in a small border surrounding all four sides of the
image.  The width of this border can be modified using the function
<!1><A HREF="GBitmap.html#DOC.1.4.13.1.3.6">minborder</A>.  The border pixels are initialized to zero and therefore
represent white pixels.  You should never write anything into border
pixels because they are shared between images and between lines.  </BLOCKQUOTE>
<DL>

<A NAME="Construction. "></A>
<A NAME="DOC.1.4.13.1.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Construction. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="GBitmap"></A>
<A NAME="DOC.1.4.13.1.1.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap()</B></TT>
<DD>Constructs an empty GBitmap object.  The returned GBitmap has zero rows
and zero columns.  Use function <!1><A HREF="GBitmap.html#DOC.1.4.13.1.2.1">init</A> to change the size of the
image. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap"></A>
<A NAME="DOC.1.4.13.1.1.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(int nrows, int ncolumns, int border=0)</B></TT>
<DD>Constructs a GBitmap with <TT>nrows</TT> rows and <TT>ncolumns</TT> columns.  All
pixels are initialized to white. The optional argument <TT>border</TT>
specifies the size of the optional border of white pixels surrounding
the image.  The number of gray levels is initially set to <TT>2</TT>.  
<DL><DT><DD></DL><P>
<A NAME="GBitmap"></A>
<A NAME="DOC.1.4.13.1.1.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(const <!1><A HREF="GBitmap.html#DOC.1.4.13.1.1.3">GBitmap</A> &amp;ref)</B></TT>
<DD>Copy constructor. Constructs a GBitmap by replicating the size, the
border and the contents of GBitmap <TT>ref</TT>. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap"></A>
<A NAME="DOC.1.4.13.1.1.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(const <!1><A HREF="GBitmap.html#DOC.1.4.13.1.1.4">GBitmap</A> &amp;ref, int border)</B></TT>
<DD>Constructs a GBitmap by copying the contents of GBitmap <TT>ref</TT>.  
Argument <TT>border</TT> specifies the width of the optional border. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap"></A>
<A NAME="DOC.1.4.13.1.1.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(const <!1><A HREF="GBitmap.html#DOC.1.4.13.1.1.5">GBitmap</A> &amp;ref, const <!1><A HREF="GRect.html">GRect</A> &amp;rect, int border=0)</B></TT>
<DD>Constructs a GBitmap by copying a rectangular segment <TT>rect</TT> of GBitmap
<TT>ref</TT>.  The optional argument <TT>border</TT> specifies the size of the
optional border of white pixels surrounding the image. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap"></A>
<A NAME="DOC.1.4.13.1.1.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;ref, int border=0)</B></TT>
<DD>Constructs a GBitmap by reading PBM, PGM or RLE data from ByteStream
<TT>ref</TT> into this GBitmap. The optional argument <TT>border</TT> specifies the
size of the optional border of white pixels surrounding the image.  See
<!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A> for more information.  
<DL><DT><DD></DL><P></DL>

<A NAME="Initialization. "></A>
<A NAME="DOC.1.4.13.1.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Initialization. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="init"></A>
<A NAME="DOC.1.4.13.1.2.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(int nrows, int ncolumns, int border=0)</B></TT>
<DD>Resets this GBitmap size to <TT>nrows</TT> rows and <TT>ncolumns</TT> columns and sets
all pixels to white.  The optional argument <TT>border</TT> specifies the size
of the optional border of white pixels surrounding the image.  The
number of gray levels is initialized to <TT>2</TT>. 
<DL><DT><DD></DL><P>
<A NAME="init"></A>
<A NAME="DOC.1.4.13.1.2.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(const <!1><A HREF="GBitmap.html">GBitmap</A> &amp;ref, int border=0)</B></TT>
<DD>Initializes this GBitmap with the contents of the GBitmap <TT>ref</TT>.  The
optional argument <TT>border</TT> specifies the size of the optional border of
white pixels surrounding the image. 
<DL><DT><DD></DL><P>
<A NAME="init"></A>
<A NAME="DOC.1.4.13.1.2.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(const <!1><A HREF="GBitmap.html">GBitmap</A> &amp;ref, const <!1><A HREF="GRect.html">GRect</A> &amp;rect, int border=0)</B></TT>
<DD>Initializes this GBitmap with a rectangular segment <TT>rect</TT> of GBitmap
<TT>ref</TT>.  The optional argument <TT>border</TT> specifies the size of the
optional border of white pixels surrounding the image. 
<DL><DT><DD></DL><P>
<A NAME="init"></A>
<A NAME="DOC.1.4.13.1.2.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;ref, int border=0)</B></TT>
<DD>Reads PBM, PGM or RLE data from ByteStream <TT>ref</TT> into this GBitmap.  The
previous content of the GBitmap object is lost. The optional argument
<TT>border</TT> specifies the size of the optional border of white pixels
surrounding the image. See <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A> for more
information. 
<DL><DT><DD></DL><P>
<A NAME="operator="></A>
<A NAME="DOC.1.4.13.1.2.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GBitmap.html">GBitmap</A>&amp; operator=(const <!1><A HREF="GBitmap.html">GBitmap</A> &amp;ref)</B></TT>
<DD>Assignment operator. Initializes this GBitmap by copying the size, the
border and the contents of GBitmap <TT>ref</TT>. 
<DL><DT><DD></DL><P>
<A NAME="fill"></A>
<A NAME="DOC.1.4.13.1.2.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void fill(unsigned char value)</B></TT>
<DD>Initializes all the GBitmap pixels to value <TT>value</TT>. 
<DL><DT><DD></DL><P></DL>

<A NAME="Accessing the pixels. "></A>
<A NAME="DOC.1.4.13.1.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Accessing the pixels. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="rows"></A>
<A NAME="DOC.1.4.13.1.3.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int rows() const </B></TT>
<DD>Returns the number of rows (the image height). 
<DL><DT><DD></DL><P>
<A NAME="columns"></A>
<A NAME="DOC.1.4.13.1.3.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int columns() const </B></TT>
<DD>Returns the number of columns (the image width). 
<DL><DT><DD></DL><P>
<A NAME="operator[] "></A>
<A NAME="DOC.1.4.13.1.3.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const unsigned char* operator[] (int row) const </B></TT>
<DD>Returns a constant pointer to the first byte of row <TT>row</TT>.
This pointer can be used as an array to read the row elements. 
<DL><DT><DD></DL><P>
<A NAME="operator[] "></A>
<A NAME="DOC.1.4.13.1.3.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned char* operator[] (int row)</B></TT>
<DD>Returns a pointer to the first byte of row <TT>row</TT>.
This pointer can be used as an array to read or write the row elements. 
<DL><DT><DD></DL><P>
<A NAME="rowsize"></A>
<A NAME="DOC.1.4.13.1.3.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int rowsize() const </B></TT>
<DD>Returns the size of a row in memory (in pixels).  This number is equal
to the difference between pointers to pixels located in the same column
in consecutive rows.  This difference can be larger than the number of
columns in the image. 
<DL><DT><DD></DL><P>
<A NAME="minborder"></A>
<A NAME="DOC.1.4.13.1.3.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void minborder(int minimum)</B></TT>
<DD>Makes sure that the border is at least <TT>minimum</TT> pixels large.  This
function does nothing it the border width is already larger than
<TT>minimum</TT>.  Otherwise it reorganizes the data in order to provide a
border of <TT>minimum</TT> pixels. 
<DL><DT><DD></DL><P></DL>

<A NAME="Managing gray levels. "></A>
<A NAME="DOC.1.4.13.1.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Managing gray levels. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="get_grays"></A>
<A NAME="DOC.1.4.13.1.4.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int get_grays() const </B></TT>
<DD>Returns the number of gray levels. 
Value <TT>2</TT> denotes a bilevel image. 
<DL><DT><DD></DL><P>
<A NAME="set_grays"></A>
<A NAME="DOC.1.4.13.1.4.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void set_grays(int grays)</B></TT>
<DD>Sets the number of gray levels without changing the pixels.
Argument <TT>grays</TT> must be in range <TT>2</TT> to <TT>256</TT>. 
<DL><DT><DD></DL><P>
<A NAME="change_grays"></A>
<A NAME="DOC.1.4.13.1.4.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void change_grays(int grays)</B></TT>
<DD>Changes the number of gray levels.  The argument <TT>grays</TT> must be in the
range <TT>2</TT> to <TT>256</TT>.  All the pixel values are then rescaled and clipped
in range <TT>0</TT> to <TT>grays-1</TT>. 
<DL><DT><DD></DL><P>
<A NAME="binarize_grays"></A>
<A NAME="DOC.1.4.13.1.4.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void binarize_grays(int threshold=0)</B></TT>
<DD>Binarizes a gray level image using a threshold.  The number of gray
levels is reduced to <TT>2</TT> as in a bilevel image.  All pixels whose value
was strictly greater than <TT>threshold</TT> are set to black. All other pixels
are set to white. 
<DL><DT><DD></DL><P></DL>

<A NAME="Optimizing the memory usage.  "></A>
<A NAME="DOC.1.4.13.1.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Optimizing the memory usage.  </B></TT>
<DD>The amount of memory used by bilevel images can be reduced using
function <!1><A HREF="GBitmap.html#DOC.1.4.13.1.5.1">compress</A>, which encodes the image using a run-length
encoding scheme.  The bracket operator decompresses the image on demand.
A few highly optimized functions (e.g. <!1><A HREF="GBitmap.html#DOC.1.4.13.1.6.1">blit</A>) can use a run-length
encoded bitmap without decompressing it.  
<DL><DT><DD></DL><P><DL>

<A NAME="compress"></A>
<A NAME="DOC.1.4.13.1.5.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void compress()</B></TT>
<DD>Reduces the memory required for a bilevel image by using a run-length
encoded representation.  Functions that need to access the pixel array
will decompress the image on demand. 
<DL><DT><DD></DL><P>
<A NAME="get_memory_usage"></A>
<A NAME="DOC.1.4.13.1.5.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int get_memory_usage() const </B></TT>
<DD>Returns the number of bytes allocated for this image. 
<DL><DT><DD></DL><P></DL>

<A NAME="Additive Blit.  "></A>
<A NAME="DOC.1.4.13.1.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Additive Blit.  </B></TT>
<DD>The blit functions are designed to efficiently construct an anti-aliased
image by copying smaller images at predefined locations.  The image of a
page, for instance, is composed by copying the images of characters at
predefined locations.  These functions are fairly optimized.  They can
directly use compressed GBitmaps (see <!1><A HREF="GBitmap.html#DOC.1.4.13.1.5.1">compress</A>).  We consider in
this section that each GBitmap comes with a coordinate system defined as
follows.  Position (<TT>0</TT>,<TT>0</TT>) corresponds to the bottom left corner of
the bottom left pixel.  Position (<TT>1</TT>,<TT>1</TT>) corresponds to the top right
corner of the bottom left pixel, which is also the bottom left corner of
the second pixel of the second row.  Position (<TT>w</TT>,<TT>h</TT>), where <TT>w</TT> and
<TT>h</TT> denote the size of the GBitmap, corresponds to the top right corner
of the top right pixel. 
<DL><DT><DD></DL><P><DL>

<A NAME="blit"></A>
<A NAME="DOC.1.4.13.1.6.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void blit(const <!1><A HREF="GBitmap.html">GBitmap</A>* bm, int x, int y)</B></TT>
<DD>Performs an additive blit of the GBitmap <TT>bm</TT>.  The GBitmap <TT>bm</TT> is
first positioned above the current GBitmap in such a way that position
(<TT>u</TT>,<TT>v</TT>) in GBitmap <TT>bm</TT> corresponds to position (<TT>u</TT>+<TT>x</TT>,<TT>v</TT>+<TT>y</TT>) in
the current GBitmap.  The value of each pixel in GBitmap <TT>bm</TT> is then
added to the value of the corresponding pixel in the current GBitmap.

<P><B>Example</B>: Assume for instance that the current GBitmap is initially
white (all pixels have value zero).  This operation copies the pixel
values of GBitmap <TT>bm</TT> at position (<TT>x</TT>,<TT>y</TT>) into the current GBitmap.
Note that function <TT>blit</TT> does not change the number of gray levels in
the current GBitmap.  You may have to call <!1><A HREF="GBitmap.html#DOC.1.4.13.1.4.2">set_grays</A> to specify
how the pixel values should be interpreted. 
<DL><DT><DD></DL><P>
<A NAME="blit"></A>
<A NAME="DOC.1.4.13.1.6.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void blit(const <!1><A HREF="GBitmap.html">GBitmap</A>* shape, int x, int y, int subsample)</B></TT>
<DD>Performs an additive blit of the GBitmap <TT>bm</TT> with anti-aliasing.  The
GBitmap <TT>bm</TT> is first positioned above the current GBitmap in such a
way that position (<TT>u</TT>,<TT>v</TT>) in GBitmap <TT>bm</TT> corresponds to position
(<TT>u</TT>+<TT>x</TT>/<TT>subsample</TT>,<TT>v</TT>+<TT>y</TT>/<TT>subsample</TT>) in the current GBitmap.  This
mapping results in a contraction of GBitmap <TT>bm</TT> by a factor
<TT>subsample</TT>.  Each pixel of the current GBitmap can be covered by a
maximum of <TT>subsample^2</TT> pixels of GBitmap <TT>bm</TT>.  The value of
each pixel in GBitmap <TT>bm</TT> is then added to the value of the
corresponding pixel in the current GBitmap.

<P><B>Example</B>: Assume for instance that the current GBitmap is initially
white (all pixels have value zero).  Each pixel of the current GBitmap
then contains the sum of the gray levels of the corresponding pixels in
GBitmap <TT>bm</TT>.  There are up to <TT>subsample*subsample</TT> such pixels.  If
for instance GBitmap <TT>bm</TT> is a bilevel image (pixels can be <TT>0</TT> or <TT>1</TT>),
the pixels of the current GBitmap can take values in range <TT>0</TT> to
<TT>subsample*subsample</TT>.  Note that function <TT>blit</TT> does not change the
number of gray levels in the current GBitmap.  You must call
<!1><A HREF="GBitmap.html#DOC.1.4.13.1.4.2">set_grays</A> to indicate that there are <TT>subsample^2+1</TT> gray
levels.  Since there is at most 256 gray levels, this also means that
<TT>subsample</TT> should never be greater than <TT>15</TT>.

<P><B>Remark</B>: Arguments <TT>x</TT> and <TT>y</TT> do not represent a position in the
coordinate system of the current GBitmap.  According to the above
discussion, the position is (<TT>x/subsample</TT>,<TT>y/subsample</TT>).  In other
words, you can position the blit with a sub-pixel resolution.  The
resulting anti-aliasing changes are paramount to the image quality. 
<DL><DT><DD></DL><P></DL>

<A NAME="Saving images.  "></A>
<A NAME="DOC.1.4.13.1.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Saving images.  </B></TT>
<DD>The following functions write PBM, PGM and RLE files.  PBM and PGM are
well known formats for bilevel and gray-level images.  The RLE is a
simple run-length encoding scheme for bilevel images. These files can be
read using the ByteStream based constructor or initialization function.
See <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A> for more information. 
<DL><DT><DD></DL><P><DL>

<A NAME="save_pbm"></A>
<A NAME="DOC.1.4.13.1.7.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void save_pbm(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int <!1><A HREF="DjVuAnno.html#DOC.1.4.18.3.5">raw</A>=1)</B></TT>
<DD>Saves the image into ByteStream <TT>bs</TT> using the PBM format.  Argument
<TT>raw</TT> selects the ``Raw PBM'' (1) or the ``Ascii PBM'' (0) format.  The
image is saved as a bilevel image.  All non zero pixels are considered
black pixels. See section <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>. 
<DL><DT><DD></DL><P>
<A NAME="save_pgm"></A>
<A NAME="DOC.1.4.13.1.7.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void save_pgm(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int <!1><A HREF="DjVuAnno.html#DOC.1.4.18.3.5">raw</A>=1)</B></TT>
<DD>Saves the image into ByteStream <TT>bs</TT> using the PGM format.  Argument
<TT>raw</TT> selects the ``Raw PGM'' (1) or the ``Ascii PGM'' (0) format.  The
image is saved as a gray level image.  See section
<!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>. 
<DL><DT><DD></DL><P>
<A NAME="save_rle"></A>
<A NAME="DOC.1.4.13.1.7.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void save_rle(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs)</B></TT>
<DD>Saves the image into ByteStream <TT>bs</TT> using the RLE file format.
The image is saved as a bilevel image. All non zero pixels are
considered black pixels. See section <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>. 
<DL><DT><DD></DL><P></DL>

<A NAME="Stealing or borrowing the memory buffer (advanced). "></A>
<A NAME="DOC.1.4.13.1.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Stealing or borrowing the memory buffer (advanced). </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="take_data"></A>
<A NAME="DOC.1.4.13.1.8.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned char* take_data(size_t &amp;offset)</B></TT>
<DD>Steals the memory buffer of a GBitmap.  This function returns the
address of the memory buffer allocated by this GBitmap object.  The
offset of the first pixel in the bottom line is written into variable
<TT>offset</TT>.  Other lines can be accessed using pointer arithmetic (see
<!1><A HREF="GBitmap.html#DOC.1.4.13.1.3.5">rowsize</A>).  The GBitmap object no longer ``owns'' the buffer: you
must explicitly de-allocate the buffer using <TT>operator&nbsp;delete&nbsp;[]</TT>.  This
de-allocation should take place after the destruction or the
re-initialization of the GBitmap object.  This function will return a
null pointer if the GBitmap object does not ``own'' the buffer in the
first place.  
<DL><DT><DD></DL><P>
<A NAME="borrow_data"></A>
<A NAME="DOC.1.4.13.1.8.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void borrow_data(unsigned char* data, int w, int h)</B></TT>
<DD>Initializes this GBitmap by borrowing a memory segment.  The GBitmap
then directly addresses the memory buffer <TT>data</TT> provided by the user.
This buffer must be large enough to hold <TT>w*h</TT> bytes.  The GBitmap
object does not ``own'' the buffer: you must explicitly de-allocate the
buffer using <TT>operator&nbsp;delete&nbsp;[]</TT>.  This de-allocation should take place
after the destruction or the re-initialization of the GBitmap object.  
<DL><DT><DD></DL><P></DL>
</DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<!-- This is were the DOC++ footer is defined  -->
