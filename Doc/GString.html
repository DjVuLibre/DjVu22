<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  GString</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  <A HREF="#DOC.DOCU">GString</A></H2></H2><BLOCKQUOTE>General purpose character string.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CGPBase,MGPBase.html,CGP,MGP.html,CGString,MGString.html">
<param name=before value="M,M,M">
<param name=after value="Md-SP,Md-,M">
<param name=indent value="0,1,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.1">GString</A></B>()
<DD><I>Null constructor.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.2">GString</A></B>(const <!1><A HREF="GString.html#DOC.1.4.4.1.2">GString</A> &amp;gs)
<DD><I>Copy constructor.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.3">GString</A></B>(const char* dat)
<DD><I>Constructs a string from a null terminated character array.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.4">GString</A></B>(const char* dat, unsigned int len)
<DD><I>Constructs a string from a character array.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.5">GString</A></B>(const <!1><A HREF="GString.html#DOC.1.4.4.1.5">GString</A> &amp;gs, int from, unsigned int len)
<DD><I>Construct a string by copying a sub-string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.6">GString</A></B>(const int number)
<DD><I>Constructs a string with a human-readable representation of integer <TT>number</TT>.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.7">GString</A></B>(const double number)
<DD><I>Constructs a string with a human-readable representation of floating point number <TT>number</TT>.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A>&amp; <B><A HREF="#DOC.1.4.4.1.8">operator= </A></B>(const <!1><A HREF="GString.html">GString</A> &amp;gs)
<DD><I>Copy operator.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A>&amp; <B><A HREF="#DOC.1.4.4.1.9">operator= </A></B>(const char* str)
<DD><I>Copy a null terminated character array.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.10">operator const char* </A></B>() const 
<DD><I>Converts a string into a constant null terminated character array.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned int <B><A HREF="#DOC.1.4.4.1.11">length</A></B>() const 
<DD><I>Returns the string length.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.1.4.4.1.12">operator! </A></B>() const 
<DD><I>Returns true if and only if the string contains zero characters.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>char <B><A HREF="#DOC.1.4.4.1.13">operator[] </A></B>(int n) const 
<DD><I>Returns the character at position <TT>n</TT>.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.1.4.4.1.14">setat</A></B>(int n, char ch)
<DD><I>Set the character at position <TT>n</TT> to value <TT>ch</TT>.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A> <B><A HREF="#DOC.1.4.4.1.15">substr</A></B>(int from, unsigned int len=1) const 
<DD><I>Returns a sub-string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A> <B><A HREF="#DOC.1.4.4.1.16">upcase</A></B>() const 
<DD><I>Returns an upper case copy of this string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A> <B><A HREF="#DOC.1.4.4.1.17">downcase</A></B>() const 
<DD><I>Returns an lower case copy of this string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.1.4.4.1.18">empty</A></B>()
<DD><I>Reinitializes a string with the null string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>char* <B><A HREF="#DOC.1.4.4.1.19">getbuf</A></B>(int n = -1)
<DD><I>Provides a direct access to the string buffer.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.1.4.4.1.20">format</A></B>(const char* fmt, ... )
<DD><I>Initializes a string with a formatted string (as in <TT>printf</TT>).</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.1.4.4.1.21">search</A></B>(char c, int from=0) const 
<DD><I>Searches character <TT>c</TT> in the string, starting at position <TT>from</TT> and scanning forward until reaching the end of the string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.1.4.4.1.22">search</A></B>(const char* str, int from=0) const 
<DD><I>Searches sub-string <TT>str</TT> in the string, starting at position <TT>from</TT> and scanning forward until reaching the end of the string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.1.4.4.1.23">rsearch</A></B>(char c, int from=-1) const 
<DD><I>Searches character <TT>c</TT> in the string, starting at position <TT>from</TT> and scanning backwards until reaching the beginning of the string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.1.4.4.1.24">rsearch</A></B>(const char* str, int from=-1) const 
<DD><I>Searches sub-string <TT>str</TT> in the string, starting at position <TT>from</TT> and scanning backwards until reaching the beginning of the string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A>&amp; <B><A HREF="#DOC.1.4.4.1.25">operator+= </A></B>(char ch)
<DD><I>Appends character <TT>ch</TT> to the string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="GString.html">GString</A>&amp; <B><A HREF="#DOC.1.4.4.1.26">operator+= </A></B>(const char* str)
<DD><I>Appends the null terminated character array <TT>str</TT> to the string.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>return <B><A HREF="#DOC.1.4.4.1.27">concat</A></B>(s1, s2)
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>return <B><A HREF="#DOC.1.4.4.1.28">strcmp</A></B>(s1, s2)
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.4.4.1.29">GString</A></B>(GStringRep* rep)
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GP.html">GP</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif> <B>operator TYPE* </B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>TYPE* <B>operator-&gt;</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>TYPE&amp; <B>operator*</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>operator== </B>(TYPE* nptr) const 
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>operator!= </B>(TYPE* nptr) const 
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GPBase.html">GPBase</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPEnabled.html">GPEnabled</A>* <B>get</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPBase.html">GPBase</A>&amp; <B>assign</B>(<!1><A HREF="GPEnabled.html">GPEnabled</A>* nptr)
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPBase.html">GPBase</A>&amp; <B>operator=</B>(const <!1><A HREF="GPBase.html">GPBase</A> &amp; obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>operator==</B>(const <!1><A HREF="GPBase.html">GPBase</A> &amp; g2) const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPEnabled.html">GPEnabled</A>* <B>ptr</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>General purpose character string.
Each instance of class <TT>GString</TT> represents a character string.
Overloaded operators provide a value semantic to <TT>GString</TT> objects.
Conversion operators and constructors transparently convert between
<TT>GString</TT> objects and <TT>const&nbsp;char*</TT> pointers.

<P>Functions taking strings as arguments should declare their arguments as
"<TT>const&nbsp;char*</TT>".  Such functions will work equally well with <TT>GString</TT>
objects since there is a fast conversion operator from <TT>GString</TT> to
"<TT>const&nbsp;char*</TT>".  Functions returning strings should return <TT>GString</TT>
objects because the class will automatically manage the necessary memory.

<P>Characters in the string can be identified by their position.  The first
character of a string is numbered zero. Negative positions represent
characters relative to the end of the string (i.e. position <TT>-1</TT> accesses
the last character of the string, position <TT>-2</TT> represents the second last
character, etc.)  </BLOCKQUOTE>
<DL>

<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString()</B></TT>
<DD>Null constructor. Constructs an empty string. 
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(const <!1><A HREF="GString.html#DOC.1.4.4.1.2">GString</A> &amp;gs)</B></TT>
<DD>Copy constructor. Constructs a string by copying the string <TT>gs</TT>. 
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(const char* dat)</B></TT>
<DD>Constructs a string from a null terminated character array. 
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(const char* dat, unsigned int len)</B></TT>
<DD>Constructs a string from a character array.  Elements of the character
array <TT>dat</TT> are added into the string until the string length reaches
<TT>len</TT> or until encountering a null character (whichever comes first). 
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(const <!1><A HREF="GString.html#DOC.1.4.4.1.5">GString</A> &amp;gs, int from, unsigned int len)</B></TT>
<DD>Construct a string by copying a sub-string. The string will be
initialized with at most <TT>len</TT> characters from string <TT>gs</TT> starting at
position <TT>from</TT>.  The length of the constructed string may be smaller
than <TT>len</TT> if the specified range is too large. 
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(const int number)</B></TT>
<DD>Constructs a string with a human-readable representation of integer
<TT>number</TT>.  The format is similar to format <TT>&quot;%d&quot;</TT> in function
<TT>printf</TT>. 
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(const double number)</B></TT>
<DD>Constructs a string with a human-readable representation of floating
point number <TT>number</TT>. The format is similar to format <TT>&quot;%f&quot;</TT> in
function <TT>printf</TT>.  
<DL><DT><DD></DL><P>
<A NAME="operator= "></A>
<A NAME="DOC.1.4.4.1.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A>&amp; operator= (const <!1><A HREF="GString.html">GString</A> &amp;gs)</B></TT>
<DD>Copy operator. Resets this string with the value of the string <TT>gs</TT>.
This operation is efficient because string memory is allocated using a
"copy-on-write" strategy. Both strings will share the same segment of
memory until one of the strings is modified. 
<DL><DT><DD></DL><P>
<A NAME="operator= "></A>
<A NAME="DOC.1.4.4.1.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A>&amp; operator= (const char* str)</B></TT>
<DD>Copy a null terminated character array. Resets this string with the
character string contained in the null terminated character array
<TT>str</TT>. 
<DL><DT><DD></DL><P>
<A NAME="operator const char* "></A>
<A NAME="DOC.1.4.4.1.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> operator const char* () const </B></TT>
<DD>Converts a string into a constant null terminated character array.  This
conversion operator is very efficient because it simply returns a
pointer to the internal string data. The returned pointer remains valid
as long as the string is unmodified. 
<DL><DT><DD></DL><P>
<A NAME="length"></A>
<A NAME="DOC.1.4.4.1.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int length() const </B></TT>
<DD>Returns the string length. 
<DL><DT><DD></DL><P>
<A NAME="operator! "></A>
<A NAME="DOC.1.4.4.1.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int operator! () const </B></TT>
<DD>Returns true if and only if the string contains zero characters.  This
operator is useful for conditional expression in control structures.
<PRE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!&nbsp;str)&nbsp;{&nbsp;...&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!!&nbsp;str)&nbsp;{&nbsp;...&nbsp;}&nbsp;&nbsp;--&nbsp;Note&nbsp;the&nbsp;double&nbsp;operator!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
Class <TT>GString</TT> does not to support syntax "<TT>if</TT> <TT>(str)</TT> <TT>{}</TT>" because
the required conversion operator introduces dangerous ambiguities with
certain compilers. 
<DL><DT><DD></DL><P>
<A NAME="operator[] "></A>
<A NAME="DOC.1.4.4.1.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>char operator[] (int n) const </B></TT>
<DD>Returns the character at position <TT>n</TT>. An exception <!1><A HREF="GException.html">GException</A> is
thrown if number <TT>n</TT> is not in range <TT>-len</TT> to <TT>len-1</TT>, where <TT>len</TT> is
the length of the string.  The first character of a string is numbered
zero.  Negative positions represent characters relative to the end of
the string. 
<DL><DT><DD></DL><P>
<A NAME="setat"></A>
<A NAME="DOC.1.4.4.1.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void setat(int n, char ch)</B></TT>
<DD>Set the character at position <TT>n</TT> to value <TT>ch</TT>.  An exception
<!1><A HREF="GException.html">GException</A> is thrown if number <TT>n</TT> is not in range <TT>-len</TT> to
<TT>len</TT>, where <TT>len</TT> is the length of the string.  If character <TT>ch</TT> is
zero, the string is truncated at position <TT>n</TT>.  The first character of a
string is numbered zero. Negative positions represent characters
relative to the end of the string. If position <TT>n</TT> is equal to the
length of the string, this function appends character <TT>ch</TT> to the end of
the string. 
<DL><DT><DD></DL><P>
<A NAME="substr"></A>
<A NAME="DOC.1.4.4.1.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A> substr(int from, unsigned int len=1) const </B></TT>
<DD>Returns a sub-string.  The sub-string is composed by copying <TT>len</TT>
characters starting at position <TT>from</TT> in this string.  The length of
the resulting string may be smaller than <TT>len</TT> if the specified range is
too large. 
<DL><DT><DD></DL><P>
<A NAME="upcase"></A>
<A NAME="DOC.1.4.4.1.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A> upcase() const </B></TT>
<DD>Returns an upper case copy of this string.  The returned string
contains a copy of the current string with all letters turned into 
upper case letters. 
<DL><DT><DD></DL><P>
<A NAME="downcase"></A>
<A NAME="DOC.1.4.4.1.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A> downcase() const </B></TT>
<DD>Returns an lower case copy of this string.  The returned string
contains a copy of the current string with all letters turned into 
lower case letters. 
<DL><DT><DD></DL><P>
<A NAME="empty"></A>
<A NAME="DOC.1.4.4.1.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void empty()</B></TT>
<DD>Reinitializes a string with the null string. 
<DL><DT><DD></DL><P>
<A NAME="getbuf"></A>
<A NAME="DOC.1.4.4.1.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>char* getbuf(int n = -1)</B></TT>
<DD>Provides a direct access to the string buffer.  Returns a pointer for
directly accessing the string buffer.  This pointer valid remains valid
as long as the string is not modified by other means.  Positive values
for argument <TT>n</TT> represent the length of the returned buffer.  The
returned string buffer will be large enough to hold at least <TT>n</TT>
characters plus a null character.  If <TT>n</TT> is positive but smaller than
the string length, the string will be truncated to <TT>n</TT> characters. 
<DL><DT><DD></DL><P>
<A NAME="format"></A>
<A NAME="DOC.1.4.4.1.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void format(const char* fmt, ... )</B></TT>
<DD>Initializes a string with a formatted string (as in <TT>printf</TT>).  The
string is re-initialized with the characters generated according to the
specified format <TT>fmt</TT> and using the optional arguments.  See the Ansi-C
function <TT>printf()</TT> for more information.  The current implementation
will cause a segmentation violation if the resulting string is longer
than 4096 characters. 
<DL><DT><DD></DL><P>
<A NAME="search"></A>
<A NAME="DOC.1.4.4.1.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int search(char c, int from=0) const </B></TT>
<DD>Searches character <TT>c</TT> in the string, starting at position <TT>from</TT> and
scanning forward until reaching the end of the string.  This function
returns the position of the matching character.  It returns <TT>-1</TT> if
character <TT>c</TT> cannot be found. 
<DL><DT><DD></DL><P>
<A NAME="search"></A>
<A NAME="DOC.1.4.4.1.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int search(const char* str, int from=0) const </B></TT>
<DD>Searches sub-string <TT>str</TT> in the string, starting at position <TT>from</TT> and
scanning forward until reaching the end of the string.  This function
returns the position of the first matching character of the sub-string.
It returns <TT>-1</TT> if string <TT>str</TT> cannot be found. 
<DL><DT><DD></DL><P>
<A NAME="rsearch"></A>
<A NAME="DOC.1.4.4.1.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int rsearch(char c, int from=-1) const </B></TT>
<DD>Searches character <TT>c</TT> in the string, starting at position <TT>from</TT> and
scanning backwards until reaching the beginning of the string.  This
function returns the position of the matching character.  It returns
<TT>-1</TT> if character <TT>c</TT> cannot be found. 
<DL><DT><DD></DL><P>
<A NAME="rsearch"></A>
<A NAME="DOC.1.4.4.1.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int rsearch(const char* str, int from=-1) const </B></TT>
<DD>Searches sub-string <TT>str</TT> in the string, starting at position <TT>from</TT> and
scanning backwards until reaching the beginning of the string.  This
function returns the position of the first matching character of the
sub-string. It returns <TT>-1</TT> if string <TT>str</TT> cannot be found. 
<DL><DT><DD></DL><P>
<A NAME="operator+= "></A>
<A NAME="DOC.1.4.4.1.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A>&amp; operator+= (char ch)</B></TT>
<DD>Appends character <TT>ch</TT> to the string. 
<DL><DT><DD></DL><P>
<A NAME="operator+= "></A>
<A NAME="DOC.1.4.4.1.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GString.html">GString</A>&amp; operator+= (const char* str)</B></TT>
<DD>Appends the null terminated character array <TT>str</TT> to the string. 
<DL><DT><DD></DL><P>
<A NAME="concat"></A>
<A NAME="DOC.1.4.4.1.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>return concat(s1, s2)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="strcmp"></A>
<A NAME="DOC.1.4.4.1.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>return strcmp(s1, s2)</B></TT>
<DL><DT><DD></DL><P>
<A NAME="GString"></A>
<A NAME="DOC.1.4.4.1.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GString(GStringRep* rep)</B></TT>
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DT><B>Friends:</B><DD>  <!1><A HREF="GString.html">GString</A> operator+(const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  <!1><A HREF="GString.html">GString</A> operator+(const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2) <BR>  <!1><A HREF="GString.html">GString</A> operator+(const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  int operator==(const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  int operator==(const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2) <BR>  int operator==(const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  int operator!=(const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator!=(const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2)<BR>  int operator!=(const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  int operator&gt;=(const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  int operator&gt;=(const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2) <BR>  int operator&gt;=(const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator&gt; (const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator&gt; (const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2) <BR>  int operator&gt; (const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator&lt;=(const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator&lt;=(const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2) <BR>  int operator&lt;=(const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator&lt; (const <!1><A HREF="GString.html">GString</A> &amp;s1, const <!1><A HREF="GString.html">GString</A> &amp;s2)<BR>  int operator&lt; (const <!1><A HREF="GString.html">GString</A> &amp;s1, const char    *s2)<BR>  int operator&lt; (const char    *s1, const <!1><A HREF="GString.html">GString</A> &amp;s2) <BR>  unsigned int <!1><A HREF="hash.html">hash</A>(const <!1><A HREF="GString.html">GString</A> &amp;ref)<BR><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<!-- This is were the DOC++ footer is defined  -->
